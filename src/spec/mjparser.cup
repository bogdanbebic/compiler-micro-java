
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    Logger log = Logger.getLogger(getClass());

    public void syntax_error(Symbol currentToken) {
        report_error("\nSyntax error", currentToken);
    }

    public void unrecovered_syntax_error(Symbol currentToken) throws Exception {
        report_fatal_error("Fatal error, parsing can't continue", currentToken);
    }

    public void report_fatal_error(String message, Object info) throws Exception {
        done_parsing();
        report_error(message, info);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
            msg.append(" on line ").append(((Symbol)info).left);

        log.error(msg.toString());
    }
:}


scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null)
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

/* keywords */
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, SWITCH, DO, WHILE, NEW, PRINT,
    READ, RETURN, VOID, EXTENDS, CONTINUE, CASE, YIELD, DEFAULT;

/* literals */
terminal Integer NUMBER;
terminal Character CHAR;
terminal Object BOOL;

/* identifiers */
terminal String IDENT;

/* operators */
terminal INC, DEC, PLUS, MINUS, MULT, DIV, MOD;
terminal EQ, NE, GE, LE, GT, LT;
terminal LAND, LOR;
terminal ASSIGN, SEMI, COMMA, DOT;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, COLON;

nonterminal Program, DeclList, MethodDeclList;
nonterminal ConstantDecl, VariableDecl, ClassDecl;
nonterminal ConstantDeclList, SingleConstantDecl;
nonterminal VariableDeclList, SingleVariableDecl;
nonterminal ClassDeclStart, ClassDeclEnd;
nonterminal OptionalInheritance, OptionalMethodDeclList;
nonterminal Type;
nonterminal MethodDecl;
nonterminal MethodParams;
nonterminal ReturnType, FormalParams, VarDeclList, StatementList;
nonterminal FormalParamsList, SingleFormalParamDecl;
nonterminal Statement;
nonterminal DesignatorStatement;
nonterminal IfCondition, OptionalElseBranch;
nonterminal OptionalWidthSpecifier;
nonterminal Condition, ConditionTerm, ConditionFactor;
nonterminal OptionalExpr, Expr, ExprTermList, SwitchExpr;
nonterminal ExpressionTerm, Term, Factor;
nonterminal CaseLabelList, CaseLabel;
nonterminal Designator;
nonterminal OptionalFunctionCall, ActualParams, ActualParamsList;
nonterminal OptionalArrayIndexing, ArrayIndexing, FieldAccess;
nonterminal AssignOp, RelOp, AddOp, MulOp;

precedence left ELSE;

Program ::= (Program) PROGRAM IDENT:programName DeclList LBRACE MethodDeclList RBRACE
          ;

DeclList ::= (NoDeclarations)      /* epsilon */
           | (ConstantDeclaration) DeclList ConstantDecl
           | (VariableDeclaration) DeclList VariableDecl
           | (ClassDeclaration)    DeclList ClassDecl
           ;

ConstantDecl ::= (ConstantDecl) CONST Type ConstantDeclList SEMI
               ;

ConstantDeclList ::= (FirstConstantDecl) SingleConstantDecl
                   | (ConstantListDecl)  ConstantDeclList COMMA SingleConstantDecl
                   ;

SingleConstantDecl ::= (NumberConstantDecl) IDENT:constantName ASSIGN NUMBER:value
                     | (CharConstantDecl)   IDENT:constantName ASSIGN CHAR:value
                     | (BoolConstantDecl)   IDENT:constantName ASSIGN BOOL:value
                     ;

VariableDecl ::= (GlobalVariableDecl)    Type VariableDeclList SEMI
               | (ErroneousVariableDecl) error COMMA:l VariableDeclList SEMI
               {: parser.report_error("Syntax error declaring variable before , on line " + lleft, null); :}
               | (ErroneousGlobalDecl)   error SEMI:l
               {: parser.report_error("Syntax error declaring variable before ; on line " + lleft, null); :}
               ;

VariableDeclList ::= (FirstVariableDecl) SingleVariableDecl
                   | (VariableListDecl)  VariableDeclList COMMA SingleVariableDecl
                   ;

SingleVariableDecl ::= (ScalarVariableDecl) IDENT:variableName
                     | (ArrayVariableDecl)  IDENT:variableName LBRACKET RBRACKET
                     ;

ClassDecl ::= (ClassDefinition) ClassDeclStart VarDeclList OptionalMethodDeclList ClassDeclEnd
            | (ErroneousFields) ClassDeclStart VarDeclList error LBRACE:l MethodDeclList RBRACE ClassDeclEnd
            // {: parser.report_error("Syntax error declaring variable before { on line " + lleft, null); :}
            // NOTE: does not work when action is present - for some reason, AST-CUP
            // changes the parsing stack offsets when the action is present and because of
            // this a ClassCastException is triggered when trying to reduce the production
            ;

ClassDeclStart ::= (ClassDeclarationStart) CLASS IDENT:className OptionalInheritance LBRACE
                 | (ErroneousInheritance)  CLASS IDENT:className error LBRACE:l
                 {: parser.report_error("Syntax error extending class before { on line " + lleft, null); :}
                 ;

ClassDeclEnd ::= RBRACE
               ;

OptionalInheritance ::= (NoInheritanceDecl) /* epsilon */
                      | (InheritanceDecl)   EXTENDS Type
                      ;

OptionalMethodDeclList ::= (NoClassMethodDeclList) /* epsilon */
                         | (ClassMethodDeclList)   LBRACE MethodDeclList RBRACE
                         ;

Type ::= (Type) IDENT:typename
       ;

MethodDeclList ::= (NoMethodDeclarations) /* epsilon */
                 | (MethodDeclarations)   MethodDeclList MethodDecl
                 ;

MethodDecl ::= (MethodDecl) ReturnType IDENT:methodName MethodParams VarDeclList LBRACE StatementList RBRACE
             ;

MethodParams ::= (ValidMethodParams)     LPAREN FormalParams RPAREN
               | (ErroneousMethodParams) LPAREN error RPAREN:l
               {: parser.report_error("Syntax error declaring formal parameter before ) on line " + lleft, null); :}
               ;

ReturnType ::= (NonVoidReturnType) Type
             | (VoidReturnType)    VOID
             ;

FormalParams ::= (NoFormalParams)   /* epsilon */
               | (FormalParamsDecl) FormalParamsList
               ;

FormalParamsList ::= (FirstFormalParamDecl) SingleFormalParamDecl
                   | (FormalParamsListDecl) FormalParamsList COMMA SingleFormalParamDecl
                   | (ErroneousFormalParam) error COMMA:l SingleFormalParamDecl:param
                   {: parser.report_error("Syntax error declaring formal parameter before , on line " + lleft, null); :}
                   ;

SingleFormalParamDecl ::= (FormalParamDecl) Type SingleVariableDecl
                        ;

VarDeclList ::= (NoVarDeclarations) /* epsilon */
              | (VarDeclaration)    VarDeclList VariableDecl
              ;

StatementList ::= (NoStatements) /* epsilon */
                | (Stmt)         StatementList Statement
                ;

Statement ::= (DesignatorStmt) DesignatorStatement SEMI
            | (IfElseStmt)     IF IfCondition Statement OptionalElseBranch
            | (DoWhileStmt)    DO Statement WHILE IfCondition SEMI
            | (YieldStmt)      YIELD Expr SEMI
            | (BreakStmt)      BREAK SEMI
            | (ContinueStmt)   CONTINUE SEMI
            | (ReturnStmt)     RETURN OptionalExpr SEMI
            | (ReadStmt)       READ LPAREN Designator RPAREN SEMI
            | (PrintStmt)      PRINT LPAREN Expr OptionalWidthSpecifier RPAREN SEMI
            | (BlockStmt)      LBRACE StatementList RBRACE
            | (ErroneousStmt)  error SEMI:l
            {: parser.report_error("Syntax error in statement before ; on line " + lleft, null); :}
            ;

IfCondition ::= (ValidIfCondition) LPAREN Condition RPAREN
              | (ErroneousIfCondition) LPAREN error RPAREN:l
              {: parser.report_error("Syntax error in condition before ) on line " + lleft, null); :}
              ;

OptionalElseBranch ::= (NoElseBranch) /* epsilon */
                     | (ElseBranch)   ELSE Statement
                     ;

OptionalWidthSpecifier ::= (NoWidthSpecifier) /* epsilon */
                         | (WidthSpecifier)   COMMA NUMBER
                         ;

DesignatorStatement ::= (AssignmentStmt) Designator AssignOp Expr
                      | (FunctionCallStmt) Designator LPAREN ActualParams RPAREN
                      | (DesignatorIncStmt) Designator INC
                      | (DesignatorDecStmt) Designator DEC
                      ;

Condition ::= (FirstConditionTerm) ConditionTerm
            | (ConditionTermList)  Condition LOR ConditionTerm
            ;

ConditionTerm ::= (FirstConditionFactor) ConditionFactor
                | (ConditionFactorList)  ConditionTerm LAND ConditionFactor
                ;

ConditionFactor ::= (FirstConditionExpr) Expr
                  | (ConditionExprList)  ConditionFactor RelOp Expr
                  ;

OptionalExpr ::= (NoExpression) /* epsilon */
               | (Expression)   Expr
               ;

Expr ::= (ExprTermListDecl) ExprTermList
       | (SwitchExprDecl)   SwitchExpr
       ;

ExprTermList ::= (SingleTerm)      ExpressionTerm
               | (AddOpExpression) ExprTermList AddOp Term
               ;

SwitchExpr ::= (SwitchExpression) SWITCH LPAREN Expr RPAREN LBRACE CaseLabelList RBRACE
             ;

CaseLabelList ::= (NoCaseLabels)  /* epsilon */
                | (CaseLabelDecl) CaseLabelList CaseLabel
                ;

CaseLabel ::= (NonDefaultCaseLabel) CASE NUMBER COLON StatementList
            | (DefaultCaseLabel)    DEFAULT COLON StatementList
            ;

ExpressionTerm ::= (PositiveTerm) Term
                 | (NegativeTerm) MINUS Term
                 ;

Term ::= (SingleFactor) Factor
       | (MulOpTerm)    Term MulOp Factor
       ;

Factor ::= (DesignatorFactor)     Designator OptionalFunctionCall
         | (NumberConstantFactor) NUMBER
         | (CharConstantFactor)   CHAR
         | (BoolConstantFactor)   BOOL
         | (AllocationFactor)     NEW Type OptionalArrayIndexing
         | (ParenthesesFactor)    LPAREN Expr RPAREN
         ;

Designator ::= (SingleIdentifier)       IDENT:designator
             | (DesignatorMemberAccess) Designator FieldAccess
             | (DesignatorArrayIndex)   Designator ArrayIndexing
             ;

OptionalFunctionCall ::= (NoFunctionCall) /* epsilon */
                       | (FunctionCall)   LPAREN ActualParams RPAREN
                       ;

ActualParams ::= (NoActualParams)   /* epsilon */
               | (ActualParamsDecl) ActualParamsList
               ;

ActualParamsList ::= (FirstActualParamDecl) Expr
                   | (ActualParamsListDecl) ActualParamsList COMMA Expr
                   ;

OptionalArrayIndexing ::= (NoArrayIndexing) /* epsilon */
                        | (ArrayIndex)      ArrayIndexing
                        ;

ArrayIndexing ::= (ArrayIndexing) LBRACKET Expr RBRACKET
                ;

FieldAccess ::= (FieldAccess) DOT IDENT:fieldName
              ;

AssignOp ::= (AssignOp) ASSIGN
           ;

RelOp ::= (EqualOp)        EQ
        | (NotEqualOp)     NE
        | (GreaterOp)      GT
        | (GreaterEqualOp) GE
        | (LessOp)         LT
        | (LessEqualOp)    LE
        ;

AddOp ::= (PlusOp) PLUS
        | (MinusOp) MINUS
        ;

MulOp ::= (MultiplyOp) MULT
        | (DivideOp)   DIV
        | (ModuloOp)   MOD
        ;
